class K2k
types

values
-- TODO Define values here
instance variables
				private stores : set of Store := {};
				inv not exists l1, l2 in set stores & 
						l1 <> l2 and l1.getID() = l2.getID(); 
				
				private range1 : Product`Range := mk_Product`Range(10, 12, 'Y');
				private range2 : Product`Range := mk_Product`Range(5, 8, 'M');
				private range3 : Product`Range := mk_Product`Range(8, 9, 'Y');
				private price1 : Product`Price := mk_Product`Price(7);
				private price2 : Product`Price := mk_Product`Price(4);
				private price3 : Product`Price := mk_Product`Price(15);
				private product1 : Product := new Product(<toy>, range1, "zippo", "carro", price1, 'M');
				private product2 : Product := new Product(<toy>, range2, "zippo", "boneca", price2, 'F');
				private product3 : Product := new Product(<clothing>, range3, "zippo", "casaco", price3, 'M');
				private inventory : set of Product := {product1, product2, product3};
				private trans: seq of Transaction := [];
				private store1 : Store := new Store(1, "Porto", inventory, trans, 100.0, 10);
				private store2 : Store := new Store(2, "Vila Real", inventory, trans, 150.0, 15);
				private store3 : Store := new Store(3, "Braga", inventory, trans, 80.0, 20);

				
operations
			public static main: () ==> ()
			main() ==
			(
				new K2k().init();
			);
			
			
			public init : () ==> ()
			init() ==
			(
				dcl client1 : Client := new Client("Ze");
				dcl trans1: Transaction ;
				--Product(stringCat, stringBrand, stringDetail, value, genderChar) 				
				
				--Store(string, products, trans, cut)
				stores := {store1, store2, store3};
				--Transaction(cli, str, prdt, t, val)
				trans1 := new Transaction(client1, store2, {product1}, <buy>);
				store2.addTransaction(trans1);
				store1.addTransaction(trans1);
				
			
				
			);
			
			--returns the store(s) with the most transactions
			public mostSales : () ==> set of Store
			mostSales() ==
			(
				dcl max : int := 0;
				dcl maxStores: set of Store := {};
				for all store in set stores do (
					if numTransactions(store) >= max then(
						if numTransactions(store) > max then(
							max := numTransactions(store);
							maxStores := {};
						);
						maxStores := {store} union maxStores;
					);
				);
				return maxStores;
			);
			
			--returns the store(s) with the highest balance
			public highestBalance : () ==> set of Store
			highestBalance() ==
			(
				dcl max : real := 0;
				dcl maxStores: set of Store := {};
				for all store in set stores do (
					if store.getBalance() >= max then(
						if store.getBalance() > max then(
							max := store.getBalance();
							maxStores := {};
						);
						maxStores := {store} union maxStores;
					);
				);
				return maxStores;
			);
			
			--returns the number of transactions of a store
			public numTransactions : Store ==> int
			numTransactions(store) ==
			(
				return len store.getTransactions();
			);
			
			--returns stores ordered by balance (bubbleSort)
			public balanceList : () ==> seq of Store
			balanceList() ==
			(
					dcl sorted_list : seq of Store := [];
					
					for all store in set stores do(
						sorted_list := sorted_list ^ [store];
					);
					
					for i = len sorted_list to 1 by -1 do
						for j = 1 to i-1 do
							if sorted_list(j).getBalance() < sorted_list(j+1).getBalance()
								then (dcl temp:Store := sorted_list(j);
								sorted_list(j) := sorted_list(j+1);
								sorted_list(j+1) := temp
							);
					return sorted_list
				);
				
			
			

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end K2k